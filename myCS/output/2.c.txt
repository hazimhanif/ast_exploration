SOURCE_FILE	0	0	RETURN_TYPE assumps_to_parent ( struct clause * e ) { struct clause_ptr * p , struct clause_ptr * q ; struct ilist * r ; int i ; char [ MAX_SPLIT_DEPTH + 1 ] assumptions ; p = NULL ; i = get_ancestors ( e , & p , & r ) ; for ( i = 0 ; i <= MAX_SPLIT_DEPTH ; i ++ ) assumptions [ i ] = 0 ; for ( q = p ; q != NULL ; q = q -> next ) { r = q -> c -> parents ; if ( r != NULL && r -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> i ; } else if ( r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> next -> i ; } else i = 0 ; if ( i != 0 ) { assumptions [ i ] = 1 ; } } i = write ( To_parent , assumptions , MAX_SPLIT_DEPTH + 1 ) ; printf ( "\n\n" ) ; p_assumption_depths ( assumptions ) ; }
FUNCTION_DEF	0	1	RETURN_TYPE assumps_to_parent ( struct clause * e ) { struct clause_ptr * p , struct clause_ptr * q ; struct ilist * r ; int i ; char [ MAX_SPLIT_DEPTH + 1 ] assumptions ; p = NULL ; i = get_ancestors ( e , & p , & r ) ; for ( i = 0 ; i <= MAX_SPLIT_DEPTH ; i ++ ) assumptions [ i ] = 0 ; for ( q = p ; q != NULL ; q = q -> next ) { r = q -> c -> parents ; if ( r != NULL && r -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> i ; } else if ( r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> next -> i ; } else i = 0 ; if ( i != 0 ) { assumptions [ i ] = 1 ; } } i = write ( To_parent , assumptions , MAX_SPLIT_DEPTH + 1 ) ; printf ( "\n\n" ) ; p_assumption_depths ( assumptions ) ; }
LEAF_NODE	0	2	RETURN_TYPE
FUNCTION_NAME	1	2	assumps_to_parent
LEAF_NODE	1	3	assumps_to_parent
PARAMETER_LIST	1	2	( struct clause * e )
LEAF_NODE	1	3	(
PARAMETER_DECL	1	3	struct clause * e
TYPE	1	4	struct clause *
TYPE_NAME	1	5	struct clause
LEAF_NODE	1	6	struct
LEAF_NODE	1	6	clause
POINTER	1	5	*
LEAF_NODE	1	6	*
NAME	1	4	e
LEAF_NODE	1	5	e
LEAF_NODE	1	3	)
LEAF_NODE	2	2	{
STATEMENTS	3	2	struct clause_ptr * p , struct clause_ptr * q ; struct ilist * r ; int i ; char [ MAX_SPLIT_DEPTH + 1 ] assumptions ; p = NULL ; i = get_ancestors ( e , & p , & r ) ; for ( i = 0 ; i <= MAX_SPLIT_DEPTH ; i ++ ) assumptions [ i ] = 0 ; for ( q = p ; q != NULL ; q = q -> next ) { r = q -> c -> parents ; if ( r != NULL && r -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> i ; } else if ( r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> next -> i ; } else i = 0 ; if ( i != 0 ) { assumptions [ i ] = 1 ; } } i = write ( To_parent , assumptions , MAX_SPLIT_DEPTH + 1 ) ; printf ( "\n\n" ) ; p_assumption_depths ( assumptions ) ;
SIMPLE_DECL	3	3	struct clause_ptr * p , struct clause_ptr * q ;
INIT_DECL_LIST	3	4	struct clause_ptr * p , struct clause_ptr * q
VAR_DECL	3	5	struct clause_ptr * p
TYPE	3	6	struct clause_ptr *
TYPE_NAME	3	7	struct clause_ptr
LEAF_NODE	3	8	struct
LEAF_NODE	3	8	clause_ptr
POINTER	3	7	*
LEAF_NODE	3	8	*
NAME	3	6	p
LEAF_NODE	3	7	p
LEAF_NODE	3	5	,
VAR_DECL	3	5	struct clause_ptr * q
TYPE	3	6	struct clause_ptr *
TYPE_NAME	3	7	struct clause_ptr
LEAF_NODE	3	8	struct
LEAF_NODE	3	8	clause_ptr
POINTER	3	7	*
LEAF_NODE	3	8	*
NAME	3	6	q
LEAF_NODE	3	7	q
LEAF_NODE	3	4	;
SIMPLE_DECL	4	3	struct ilist * r ;
VAR_DECL	4	4	struct ilist * r
TYPE	4	5	struct ilist *
TYPE_NAME	4	6	struct ilist
LEAF_NODE	4	7	struct
LEAF_NODE	4	7	ilist
POINTER	4	6	*
LEAF_NODE	4	7	*
NAME	4	5	r
LEAF_NODE	4	6	r
LEAF_NODE	4	4	;
SIMPLE_DECL	5	3	int i ;
VAR_DECL	5	4	int i
TYPE	5	5	int
TYPE_NAME	5	6	int
LEAF_NODE	5	7	int
NAME	5	5	i
LEAF_NODE	5	6	i
LEAF_NODE	5	4	;
SIMPLE_DECL	6	3	char [ MAX_SPLIT_DEPTH + 1 ] assumptions ;
VAR_DECL	6	4	char [ MAX_SPLIT_DEPTH + 1 ] assumptions
TYPE	6	5	char [ MAX_SPLIT_DEPTH + 1 ]
TYPE_NAME	6	6	char
LEAF_NODE	6	7	char
TYPE_SUFFIX	6	6	[ MAX_SPLIT_DEPTH + 1 ]
LEAF_NODE	6	7	[
FIELD	6	7	MAX_SPLIT_DEPTH
LEAF_NODE	6	8	MAX_SPLIT_DEPTH
LEAF_NODE	6	7	+
FIELD	6	7	1
LEAF_NODE	6	8	1
LEAF_NODE	6	7	]
NAME	6	5	assumptions
LEAF_NODE	6	6	assumptions
LEAF_NODE	6	4	;
EXPR_STATEMENT	8	3	p = NULL ;
EXPR	8	4	p = NULL
ASSIGN	8	5	p = NULL
LVAL	8	6	p
FIELD	8	7	p
LEAF_NODE	8	8	p
ASSIGN_OP	8	6	=
LEAF_NODE	8	7	=
RVAL	8	6	NULL
FIELD	8	7	NULL
LEAF_NODE	8	8	NULL
LEAF_NODE	8	4	;
EXPR_STATEMENT	9	3	i = get_ancestors ( e , & p , & r ) ;
EXPR	9	4	i = get_ancestors ( e , & p , & r )
ASSIGN	9	5	i = get_ancestors ( e , & p , & r )
LVAL	9	6	i
FIELD	9	7	i
LEAF_NODE	9	8	i
ASSIGN_OP	9	6	=
LEAF_NODE	9	7	=
RVAL	9	6	get_ancestors ( e , & p , & r )
FUNCTION_CALL	9	7	get_ancestors ( e , & p , & r )
CALLEE	9	8	get_ancestors
LEAF_NODE	9	9	get_ancestors
LEAF_NODE	9	8	(
ARGUMENT	9	8	e
FIELD	9	9	e
LEAF_NODE	9	10	e
LEAF_NODE	9	8	,
ARGUMENT	9	8	& p
UNARY_EXPR	9	9	& p
UNARY_OPERATOR	9	10	&
LEAF_NODE	9	11	&
FIELD	9	10	p
LEAF_NODE	9	11	p
LEAF_NODE	9	8	,
ARGUMENT	9	8	& r
UNARY_EXPR	9	9	& r
UNARY_OPERATOR	9	10	&
LEAF_NODE	9	11	&
FIELD	9	10	r
LEAF_NODE	9	11	r
LEAF_NODE	9	8	)
LEAF_NODE	9	4	;
ITERATION	11	3	for ( i = 0 ; i <= MAX_SPLIT_DEPTH ; i ++ ) assumptions [ i ] = 0 ;
KEYWORD	11	4	for
LEAF_NODE	11	5	for
LEAF_NODE	11	4	(
FOR_INIT	11	4	i = 0 ;
EXPR	11	5	i = 0
ASSIGN	11	6	i = 0
LVAL	11	7	i
FIELD	11	8	i
LEAF_NODE	11	9	i
ASSIGN_OP	11	7	=
LEAF_NODE	11	8	=
RVAL	11	7	0
FIELD	11	8	0
LEAF_NODE	11	9	0
LEAF_NODE	11	5	;
CONDITION	11	4	i <= MAX_SPLIT_DEPTH
EXPR	11	5	i <= MAX_SPLIT_DEPTH
FIELD	11	6	i
LEAF_NODE	11	7	i
REL_OPERATOR	11	6	<=
LEAF_NODE	11	7	<=
FIELD	11	6	MAX_SPLIT_DEPTH
LEAF_NODE	11	7	MAX_SPLIT_DEPTH
LEAF_NODE	11	4	;
FOR_EXPR	11	4	i ++
EXPR	11	5	i ++
FIELD	11	6	i ++
LEAF_NODE	11	7	i
LEAF_NODE	11	7	++
LEAF_NODE	11	4	)
STATEMENTS	12	4	assumptions [ i ] = 0 ;
EXPR_STATEMENT	12	5	assumptions [ i ] = 0 ;
EXPR	12	6	assumptions [ i ] = 0
ASSIGN	12	7	assumptions [ i ] = 0
LVAL	12	8	assumptions [ i ]
FIELD	12	9	assumptions [ i ]
LEAF_NODE	12	10	assumptions
LEAF_NODE	12	10	[
EXPR	12	10	i
FIELD	12	11	i
LEAF_NODE	12	12	i
LEAF_NODE	12	10	]
ASSIGN_OP	12	8	=
LEAF_NODE	12	9	=
RVAL	12	8	0
FIELD	12	9	0
LEAF_NODE	12	10	0
LEAF_NODE	12	6	;
ITERATION	14	3	for ( q = p ; q != NULL ; q = q -> next ) { r = q -> c -> parents ; if ( r != NULL && r -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> i ; } else if ( r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> next -> i ; } else i = 0 ; if ( i != 0 ) { assumptions [ i ] = 1 ; } }
KEYWORD	14	4	for
LEAF_NODE	14	5	for
LEAF_NODE	14	4	(
FOR_INIT	14	4	q = p ;
EXPR	14	5	q = p
ASSIGN	14	6	q = p
LVAL	14	7	q
FIELD	14	8	q
LEAF_NODE	14	9	q
ASSIGN_OP	14	7	=
LEAF_NODE	14	8	=
RVAL	14	7	p
FIELD	14	8	p
LEAF_NODE	14	9	p
LEAF_NODE	14	5	;
CONDITION	14	4	q != NULL
EXPR	14	5	q != NULL
FIELD	14	6	q
LEAF_NODE	14	7	q
EQ_OPERATOR	14	6	!=
LEAF_NODE	14	7	!=
FIELD	14	6	NULL
LEAF_NODE	14	7	NULL
LEAF_NODE	14	4	;
FOR_EXPR	14	4	q = q -> next
EXPR	14	5	q = q -> next
ASSIGN	14	6	q = q -> next
LVAL	14	7	q
FIELD	14	8	q
LEAF_NODE	14	9	q
ASSIGN_OP	14	7	=
LEAF_NODE	14	8	=
RVAL	14	7	q -> next
FIELD	14	8	q -> next
LEAF_NODE	14	9	q
LEAF_NODE	14	9	->
LEAF_NODE	14	9	next
LEAF_NODE	14	4	)
STATEMENTS	14	4	{ r = q -> c -> parents ; if ( r != NULL && r -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> i ; } else if ( r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> next -> i ; } else i = 0 ; if ( i != 0 ) { assumptions [ i ] = 1 ; } }
LEAF_NODE	14	5	{
STATEMENTS	15	5	r = q -> c -> parents ; if ( r != NULL && r -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> i ; } else if ( r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> next -> i ; } else i = 0 ; if ( i != 0 ) { assumptions [ i ] = 1 ; }
EXPR_STATEMENT	15	6	r = q -> c -> parents ;
EXPR	15	7	r = q -> c -> parents
ASSIGN	15	8	r = q -> c -> parents
LVAL	15	9	r
FIELD	15	10	r
LEAF_NODE	15	11	r
ASSIGN_OP	15	9	=
LEAF_NODE	15	10	=
RVAL	15	9	q -> c -> parents
FIELD	15	10	q -> c -> parents
LEAF_NODE	15	11	q
LEAF_NODE	15	11	->
LEAF_NODE	15	11	c
LEAF_NODE	15	11	->
LEAF_NODE	15	11	parents
LEAF_NODE	15	7	;
SELECTION	17	6	if ( r != NULL && r -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> i ; }
KEYWORD	17	7	if
LEAF_NODE	17	8	if
LEAF_NODE	17	7	(
CONDITION	17	7	r != NULL && r -> i == SPLIT_RULE
EXPR	17	8	r != NULL && r -> i == SPLIT_RULE
AND	17	9	r != NULL && r -> i == SPLIT_RULE
EXPR	17	10	r != NULL
FIELD	17	11	r
LEAF_NODE	17	12	r
EQ_OPERATOR	17	11	!=
LEAF_NODE	17	12	!=
FIELD	17	11	NULL
LEAF_NODE	17	12	NULL
LEAF_NODE	17	10	&&
EXPR	17	10	r -> i == SPLIT_RULE
FIELD	17	11	r -> i
LEAF_NODE	17	12	r
LEAF_NODE	17	12	->
LEAF_NODE	17	12	i
EQ_OPERATOR	17	11	==
LEAF_NODE	17	12	==
FIELD	17	11	SPLIT_RULE
LEAF_NODE	17	12	SPLIT_RULE
LEAF_NODE	17	7	)
STATEMENTS	17	7	{ i = LIST_RULE - r -> next -> i ; }
LEAF_NODE	17	8	{
STATEMENTS	18	8	i = LIST_RULE - r -> next -> i ;
EXPR_STATEMENT	18	9	i = LIST_RULE - r -> next -> i ;
EXPR	18	10	i = LIST_RULE - r -> next -> i
ASSIGN	18	11	i = LIST_RULE - r -> next -> i
LVAL	18	12	i
FIELD	18	13	i
LEAF_NODE	18	14	i
ASSIGN_OP	18	12	=
LEAF_NODE	18	13	=
RVAL	18	12	LIST_RULE - r -> next -> i
FIELD	18	13	LIST_RULE
LEAF_NODE	18	14	LIST_RULE
LEAF_NODE	18	13	-
FIELD	18	13	r -> next -> i
LEAF_NODE	18	14	r
LEAF_NODE	18	14	->
LEAF_NODE	18	14	next
LEAF_NODE	18	14	->
LEAF_NODE	18	14	i
LEAF_NODE	18	10	;
LEAF_NODE	19	8	}
SELECTION	20	6	else if ( r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> next -> i ; }
KEYWORD	20	7	else
LEAF_NODE	20	8	else
STATEMENTS	20	7	if ( r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> next -> i ; }
SELECTION	20	8	if ( r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE ) { i = LIST_RULE - r -> next -> next -> i ; }
KEYWORD	20	9	if
LEAF_NODE	20	10	if
LEAF_NODE	20	9	(
CONDITION	20	9	r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE
EXPR	20	10	r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE
AND	20	11	r != NULL && r -> next != NULL && r -> next -> i == SPLIT_RULE
EXPR	20	12	r != NULL
FIELD	20	13	r
LEAF_NODE	20	14	r
EQ_OPERATOR	20	13	!=
LEAF_NODE	20	14	!=
FIELD	20	13	NULL
LEAF_NODE	20	14	NULL
LEAF_NODE	20	12	&&
EXPR	20	12	r -> next != NULL && r -> next -> i == SPLIT_RULE
AND	20	13	r -> next != NULL && r -> next -> i == SPLIT_RULE
EXPR	20	14	r -> next != NULL
FIELD	20	15	r -> next
LEAF_NODE	20	16	r
LEAF_NODE	20	16	->
LEAF_NODE	20	16	next
EQ_OPERATOR	20	15	!=
LEAF_NODE	20	16	!=
FIELD	20	15	NULL
LEAF_NODE	20	16	NULL
LEAF_NODE	20	14	&&
EXPR	20	14	r -> next -> i == SPLIT_RULE
FIELD	20	15	r -> next -> i
LEAF_NODE	20	16	r
LEAF_NODE	20	16	->
LEAF_NODE	20	16	next
LEAF_NODE	20	16	->
LEAF_NODE	20	16	i
EQ_OPERATOR	20	15	==
LEAF_NODE	20	16	==
FIELD	20	15	SPLIT_RULE
LEAF_NODE	20	16	SPLIT_RULE
LEAF_NODE	20	9	)
STATEMENTS	20	9	{ i = LIST_RULE - r -> next -> next -> i ; }
LEAF_NODE	20	10	{
STATEMENTS	21	10	i = LIST_RULE - r -> next -> next -> i ;
EXPR_STATEMENT	21	11	i = LIST_RULE - r -> next -> next -> i ;
EXPR	21	12	i = LIST_RULE - r -> next -> next -> i
ASSIGN	21	13	i = LIST_RULE - r -> next -> next -> i
LVAL	21	14	i
FIELD	21	15	i
LEAF_NODE	21	16	i
ASSIGN_OP	21	14	=
LEAF_NODE	21	15	=
RVAL	21	14	LIST_RULE - r -> next -> next -> i
FIELD	21	15	LIST_RULE
LEAF_NODE	21	16	LIST_RULE
LEAF_NODE	21	15	-
FIELD	21	15	r -> next -> next -> i
LEAF_NODE	21	16	r
LEAF_NODE	21	16	->
LEAF_NODE	21	16	next
LEAF_NODE	21	16	->
LEAF_NODE	21	16	next
LEAF_NODE	21	16	->
LEAF_NODE	21	16	i
LEAF_NODE	21	12	;
LEAF_NODE	22	10	}
SELECTION	23	6	else i = 0 ;
KEYWORD	23	7	else
LEAF_NODE	23	8	else
STATEMENTS	24	7	i = 0 ;
EXPR_STATEMENT	24	8	i = 0 ;
EXPR	24	9	i = 0
ASSIGN	24	10	i = 0
LVAL	24	11	i
FIELD	24	12	i
LEAF_NODE	24	13	i
ASSIGN_OP	24	11	=
LEAF_NODE	24	12	=
RVAL	24	11	0
FIELD	24	12	0
LEAF_NODE	24	13	0
LEAF_NODE	24	9	;
SELECTION	25	6	if ( i != 0 ) { assumptions [ i ] = 1 ; }
KEYWORD	25	7	if
LEAF_NODE	25	8	if
LEAF_NODE	25	7	(
CONDITION	25	7	i != 0
EXPR	25	8	i != 0
FIELD	25	9	i
LEAF_NODE	25	10	i
EQ_OPERATOR	25	9	!=
LEAF_NODE	25	10	!=
FIELD	25	9	0
LEAF_NODE	25	10	0
LEAF_NODE	25	7	)
STATEMENTS	25	7	{ assumptions [ i ] = 1 ; }
LEAF_NODE	25	8	{
STATEMENTS	30	8	assumptions [ i ] = 1 ;
EXPR_STATEMENT	30	9	assumptions [ i ] = 1 ;
EXPR	30	10	assumptions [ i ] = 1
ASSIGN	30	11	assumptions [ i ] = 1
LVAL	30	12	assumptions [ i ]
FIELD	30	13	assumptions [ i ]
LEAF_NODE	30	14	assumptions
LEAF_NODE	30	14	[
EXPR	30	14	i
FIELD	30	15	i
LEAF_NODE	30	16	i
LEAF_NODE	30	14	]
ASSIGN_OP	30	12	=
LEAF_NODE	30	13	=
RVAL	30	12	1
FIELD	30	13	1
LEAF_NODE	30	14	1
LEAF_NODE	30	10	;
LEAF_NODE	31	8	}
LEAF_NODE	32	5	}
EXPR_STATEMENT	33	3	i = write ( To_parent , assumptions , MAX_SPLIT_DEPTH + 1 ) ;
EXPR	33	4	i = write ( To_parent , assumptions , MAX_SPLIT_DEPTH + 1 )
ASSIGN	33	5	i = write ( To_parent , assumptions , MAX_SPLIT_DEPTH + 1 )
LVAL	33	6	i
FIELD	33	7	i
LEAF_NODE	33	8	i
ASSIGN_OP	33	6	=
LEAF_NODE	33	7	=
RVAL	33	6	write ( To_parent , assumptions , MAX_SPLIT_DEPTH + 1 )
FUNCTION_CALL	33	7	write ( To_parent , assumptions , MAX_SPLIT_DEPTH + 1 )
CALLEE	33	8	write
LEAF_NODE	33	9	write
LEAF_NODE	33	8	(
ARGUMENT	33	8	To_parent
FIELD	33	9	To_parent
LEAF_NODE	33	10	To_parent
LEAF_NODE	33	8	,
ARGUMENT	33	8	assumptions
FIELD	33	9	assumptions
LEAF_NODE	33	10	assumptions
LEAF_NODE	33	8	,
ARGUMENT	33	8	MAX_SPLIT_DEPTH + 1
FIELD	33	9	MAX_SPLIT_DEPTH
LEAF_NODE	33	10	MAX_SPLIT_DEPTH
LEAF_NODE	33	9	+
FIELD	33	9	1
LEAF_NODE	33	10	1
LEAF_NODE	33	8	)
LEAF_NODE	33	4	;
EXPR_STATEMENT	34	3	printf ( "\n\n" ) ;
EXPR	34	4	printf ( "\n\n" )
FUNCTION_CALL	34	5	printf ( "\n\n" )
CALLEE	34	6	printf
LEAF_NODE	34	7	printf
LEAF_NODE	34	6	(
ARGUMENT	34	6	"\n\n"
FIELD	34	7	"\n\n"
LEAF_NODE	34	8	"\n\n"
LEAF_NODE	34	6	)
LEAF_NODE	34	4	;
EXPR_STATEMENT	34	3	p_assumption_depths ( assumptions ) ;
EXPR	34	4	p_assumption_depths ( assumptions )
FUNCTION_CALL	34	5	p_assumption_depths ( assumptions )
CALLEE	34	6	p_assumption_depths
LEAF_NODE	34	7	p_assumption_depths
LEAF_NODE	34	6	(
ARGUMENT	34	6	assumptions
FIELD	34	7	assumptions
LEAF_NODE	34	8	assumptions
LEAF_NODE	34	6	)
LEAF_NODE	34	4	;
LEAF_NODE	35	2	}
